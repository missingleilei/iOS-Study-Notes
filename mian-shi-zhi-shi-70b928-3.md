#### 1.堆和栈的含义及区别？

堆：由开发人员分配释放，若开放人员不释放，程序结束时由系统回收，分配方式类似于链表，堆区用来开辟和回收空间的分别是malloc和free。速度快，容易产生碎片，但用起来方便灵活。

栈：由操作系统自动分配释放，存放函数的参数值，局部变量等。其操作方式类似于数据结构中的栈，先进后出。速度慢，但程序员无法控制。

#### 2.Static关键字的作用？

一、设置变量的存储域，函数体内static变量的作用范围为该函数体，该变量的内存只被分配一次，因此其值在下次调用时仍保存上次的值。

二、限制变量的作用域，在模块内的Static全局变量可以被模块内的所有函数访问，但不能被模块外的函数访问。

三、限制函数的作用域，在模块内的Static函数只可被这一模块内的其他函数调用，但不能被模块外的函数访问。

#### 3.类别Category和类扩展Extension的区别？

类别Category：可以为有源代码和无源代码的类扩充功能，而且只能添加方法且方法必须实现，子类可以继承，也可以直接访问。

类扩展Extension：只能为有源代码的类扩充功能，且不光可以添加方法还可以添加实例变量，但方法和实例变量都是私有的，子类可以继承但是不能直接访问。

#### 4.线程和进程的区别和联系？

线程是指进程内的一块执行单元，也是执行任务的基本单位。

一、地址空间：进程内的一个执行单元，进程至少有一个线程，他们共享进程的地址空间，而进程有自己独立的地址空间。

二、资源拥有：进程是资源分配和拥有的单位，同一个进程内的线程共享进程的资源。

三、线程是处理器调度的基本单位而进程不是。

四、二者均可并发执行。

#### 5.UIViewController的生命周期方法调用顺序？

alloc创建对象分配空间--init（initWithNibNAme：bundle：）初始化对象及数据--loadView--ViewDidLoad--ViewWillAppear--ViewDidAppear--ViewWillDisappear-ViewDidDisAppear--dealloc。

#### 6.Objective的动态性体现在哪些方面？

动态类型：id，instanceType

动态绑定：runtime

动态加载：懒加载

#### 7.NULL、nil、Nil、NSNull之间的区别？

NULL是宏，是对于C语言指针而实用代表空指针。

nil是宏，是对于OC中对象而使用的代表对象为空。

Nil是宏，是对于OC中的类而使用的代表类指向空。

NSNull是类类型，是用于表示空的站位对象。

#### 8.copy mutablecopy srong区别？引用计数改变

* assign与weak 

两者都是弱引用，assign通常用于普通类型属性（如int,NSInteger），还有代理属性的修饰，基本上来说两者是可以通用的。 

只是后者比前者多了一个功能，后者会在引用的对象被释放的时候将该属性置为nil，而前者依然会指向原来的位置，这样就会变成野指针。在oc中你给你一个nil对象发送消息不会crash，但是给一个对象发送他不能解析的消息是会crash的，所以总的来说weak要比assign安全一些。 像delegate属性建议用weak修饰而不是assign。

* retain和strong 

他俩都是强引用，除了某些情况下不一样，其他的时候也是可以通用的。 

在修饰block属性的时候，相信大家都知道要用copy吧，因为如果不copy的话，block是存放在栈连里面的，他的生命周期会随着函数的结束而出栈的，copy之后会放在堆里面。 strong在修饰block的时候就相当于copy，而retain修饰block的时候就相当于assign，这样block会出现提前被释放掉的危险。

* assign：

用于对基本数据类型进行赋值操作，不更改引用计数。也可以用来修饰对象，但是，被assign修饰的对象在释放后，指针的地址还是存在的，也就是说指针并没有被置为nil，成为野指针。如果后续在分配对象到堆上的某块内存时，正好分到这块地址，程序就会crash。之所以可以修饰基本数据类型，因为基本数据类型一般分配在栈上，栈的内存会由系统自动处理，不会造成野指针。

* weak：

修饰Object类型，修饰的对象在释放后，指针地址会被置为nil，是一种弱引用。 

* delegate为何要用weak修饰:

在ARC环境下，为避免循环引用，往往会把delegate属性用weak修饰；在MRC下使用assign修饰。weak和strong不同的是：当一个对象不再有strong类型的指针指向它的时候，它就会被释放，即使还有weak型指针指向它，那么这些weak型指针也将被清除。

ARC下的strong等同于MRC下的retain都会把对象引用计数加1。

* copy：

会在内存里拷贝一份对象，两个指针指向不同的内存地址。一般用来修饰NSString等有对应可变类型的对象，因为他们有可能和对应的可变类型（NSMutableString）之间进行赋值操作，为确保对象中的字符串不被修改 ，应该在设置属性是拷贝一份。而若用strong修饰，如果对象在外部被修改了，会影响到属性。

* block属性为什么需要用copy来修饰？

因为在MRC下，block在创建的时候，它的内存是分配在栈\(stack\)上的，而不是在堆\(heap\)上，可能被随时回收。他本身的作于域是属于创建时候的作用域，一旦在创建时候的作用域外面调用block将导致程序崩溃。通过copy可以把block拷贝（copy）到堆，保证block的声明域外使用。在ARC下写不写都行，编译器会自动对block进行copy操作。

\_\_block与\_\_weak的区别

\_\_block：在ARC和MRC下都可用，可修饰对象，也可以修饰基本数据类型。

\_\_block对象可以在block被重新赋值，\_\_weak不可以。

\_\_weak：只在ARC中使用，只能修饰对象，不能修饰基本数据类型（int、bool）。

同时，在ARC下，要避免block出现循环引用，经常会：\_\_weak typedof\(self\) weakSelf = self;

#### 9.一个网址的组成？

1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符

2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用

3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口

4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”

5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“\#”为止，是文件部分，如果没有“？”和“\#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名

6.锚部分：从“\#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分

7.参数部分：从“？”开始到“\#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。

#### 10.自动缓冲池机制？

##### 降低内存使用峰值：

这一点不用多说，当你使用类似for循环这样的逻辑需要产生大量的中间变量时，Autorelease Pool无意是最佳的一种解决方案；

1.什么是@autoreleasepool? 

2.里面对象的内存什么时候释放? 

3.什么时候要用@autoreleasepool?

回答： 

1.@autoreleasepool是自动释放池，让我们更自由的管理内存

2.当我们手动创建了一个@autoreleasepool，里面创建了很多临时变量，当@autoreleasepool结束时，里面的内存就会回收

3.ARC时代，系统自动管理自己的autoreleasepool，runloop就是iOS中的消息循环机制，当一个runloop结束时系统才会一次性清理掉被autorelease处理过的对象，其实本质上说是在本次runloop迭代结束时清理掉被本次迭代期间被放到autorelease pool中的对象的。至于何时runloop结束并没有固定的duration。 

方便是方便了，但是有些情况下，我们还是需要手动创建自动释放池，那么，什么时候呢？

* 如果你正在编写不基于UI 框架的程序，比如命令行工具。
* 如果你编写的循环创建了很多临时对象。 
  你可以在循环中使用自动释放池block，在下次迭代前处理这些对象。在循环中使用自动释放池block，有助于减少应用程序的内存占用。
* 你生成了一个辅助线程。 一旦线程开始执行你必须自己创建自动释放池。否则，应用将泄漏对象。



